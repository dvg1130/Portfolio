## String Obfuscation Malware Simulation & Analysis

This project simulates how string obfuscation is used in malware to hide intent and evade detection. The compiled Python script mimics malicious behavior while using several common obfuscation techniques. Additionally, the project demonstrates how string obfuscation can be used to wrap and conceal code written in other languages (such as PowerShell, JavaScript, or shell commands) within Python scripts. The binary is then analyzed using string extraction and reverse engineering tools.

## Objective

To understand how string obfuscation affects static analysis of binaries, and how defenders can reverse such obfuscation through tools and deobfuscation logic.

## Techniques Used

- chr()-based string construction
- XOR encoding of strings
- Base64-encoded commands or logic
- Use of eval() or dynamic execution
- Compilation into a standalone .exe using PyInstaller

## Example Obfuscated Code

import base64
import os

 - XOR-encoded string (reversible)
url = ''.join([chr(ord(c)^3) for c in 'https://malicious.example.com'])
decoded_url = ''.join([chr(ord(c)^3) for c in url])

- Base64-encoded shell command
cmd = base64.b64decode("ZWNobyAiV2hvIGFteSBwYXllciBub3c/Igo=").decode()

- Execution
os.system(cmd)

## Executable Creation

To build the .exe:
- pip install pyinstaller
- pyinstaller --onefile payload.py
(This creates dist/payload.exe)

## Analysis Methods

ASCII Strings

Run from terminal:
- strings dist/payload.exe > strings_ascii.txt
- strings dist/payload > strings_ascii.txt

You may see internal Python loader strings, partial encoded payloads, or hints like:
- PYZ
- _MEIPASS
- failed to extract


## Unicode Strings

- macOS users (BSD strings does not support -e l):
Use radare2: r2 -q -c 'iz' dist/payload.exe
Or use gstrings via brew install binutils

- Linux users:
strings -a -e l dist/payload.exe > unicode.txt

- Windows users (Sysinternals):
strings.exe -u dist/payload.exe


## Static & Dynamic Analysis

Use Ghidra or Cutter to inspect structure and embedded strings.
Optionally analyze runtime behavior in a sandbox environment.

Look for:
- Eval use
- XOR loops
- Base64 decoding
- Suspicious system calls
- Deobfuscation Examples

    - XOR Decoder (Python)

        def xor_decrypt(data, key):
        return ''.join(chr(c ^ key) for c in data)

    - Base64 Decoder

        import base64
        decoded = base64.b64decode("ZWNobyAiV2hvIGFteSBwYXllciBub3c/Igo=").decode()
        print(decoded)


## Ghidra Walkthrough

- Launch Ghidra and import the compiled executable (payload.exe) into a new project.
- Run the default analysis when prompted.
- Open the "Defined Strings" window via Window > Defined Strings to search for visible strings.
- In the Symbol Tree, expand the "Functions" section and locate likely decryption or unpacking routines.
- Use the Decompiler window to examine decoded logic and identify where exec, os.system, or other dynamic   behaviors appear.
- Add labels and comments to track decoding functions and calls.
- Export any interesting function decompilation for documentation or manual review.


## Takeaways

String obfuscation is highly effective at defeating naive string scanners.
Encoded strings may only become visible at runtime.
Detecting obfuscation requires pattern recognition, heuristic scanning, or full emulation.

